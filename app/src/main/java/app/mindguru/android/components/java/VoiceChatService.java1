package app.mindguru.android.components.java;


import com.google.api.gax.rpc.ClientStream;
import com.google.api.gax.rpc.ResponseObserver;
import com.google.api.gax.rpc.StreamController;
import com.google.cloud.speech.v1p1beta1.RecognitionConfig;
import com.google.cloud.speech.v1p1beta1.SpeechClient;
import com.google.cloud.speech.v1p1beta1.SpeechRecognitionAlternative;
import com.google.cloud.speech.v1p1beta1.StreamingRecognitionConfig;
import com.google.cloud.speech.v1p1beta1.StreamingRecognitionResult;
import com.google.cloud.speech.v1p1beta1.StreamingRecognizeRequest;
import com.google.cloud.speech.v1p1beta1.StreamingRecognizeResponse;
import com.google.protobuf.ByteString;
import com.google.protobuf.Duration;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import mg.dida.javax.sound.share.classes.javax.sound.sampled.AudioFormat;
import mg.dida.javax.sound.share.classes.javax.sound.sampled.AudioSystem;
import mg.dida.javax.sound.share.classes.javax.sound.sampled.DataLine;
import mg.dida.javax.sound.share.classes.javax.sound.sampled.LineUnavailableException;
import mg.dida.javax.sound.share.classes.javax.sound.sampled.TargetDataLine;

public class VoiceChatService {

    private static final int STREAMING_LIMIT = 290000; // ~5 minutes
    private static final int BYTES_PER_BUFFER = 6400; // buffer size in bytes

    private SpeechClient speechClient;
    private TargetDataLine targetDataLine;
    private BlockingQueue<byte[]> sharedQueue = new LinkedBlockingQueue<>();
    private ArrayList<ByteString> audioInput = new ArrayList<>();
    private ArrayList<ByteString> lastAudioInput = new ArrayList<>();
    private int resultEndTimeInMS = 0;
    private int isFinalEndTime = 0;
    private int finalRequestEndTime = 0;
    private boolean newStream = true;
    private double bridgingOffset = 0;
    private boolean lastTranscriptWasFinal = false;
    private StreamController referenceToStreamController;
    private ByteString tempByteString;
    private int restartCounter = 0;
    private Thread micThread;


    public interface SpeechRecognitionListener {
        void onTranscriptReceived(String transcript);
    }

    private SpeechRecognitionListener listener;

    public void setSpeechRecognitionListener(SpeechRecognitionListener listener) {
        this.listener = listener;
    }

    public void pauseRecognition() {
        if (targetDataLine != null && targetDataLine.isOpen()) {
            targetDataLine.stop();
        }
        if (micThread != null && micThread.isAlive()) {
            micThread.interrupt();
        }
    }

    public void resumeRecognition(String languageCode) throws Exception {
        if (targetDataLine != null && !targetDataLine.isOpen()) {
            targetDataLine.open();
            targetDataLine.start();
        }
        if (micThread == null || !micThread.isAlive()) {
            micThread = new Thread(new MicBuffer());
            micThread.start();
        }
        startRecognition(languageCode);
    }

    public void startVoiceChat(String languageCode) throws Exception {
        initializeSpeechClient();
        startMicrophone();
        startRecognition(languageCode);
    }

    public void stopVoiceChat() {
        if (targetDataLine != null && targetDataLine.isOpen()) {
            targetDataLine.stop();
            targetDataLine.close();
        }
        if (micThread != null && micThread.isAlive()) {
            micThread.interrupt();
        }
        if (speechClient != null) {
            speechClient.close();
        }
    }

    private void initializeSpeechClient() throws Exception {
        speechClient = SpeechClient.create();
    }

    private void startMicrophone() throws LineUnavailableException {
        AudioFormat audioFormat = new AudioFormat(16000, 16, 1, true, false);
        DataLine.Info targetInfo = new DataLine.Info(TargetDataLine.class, audioFormat);

        if (!AudioSystem.isLineSupported(targetInfo)) {
            throw new LineUnavailableException("Microphone not supported");
        }

        targetDataLine = (TargetDataLine) AudioSystem.getLine(targetInfo);
        targetDataLine.open(audioFormat);

        micThread = new Thread(new MicBuffer());
        micThread.start();
    }

    private void startRecognition(String languageCode) {
        ResponseObserver<StreamingRecognizeResponse> responseObserver = new ResponseObserver<StreamingRecognizeResponse>() {
            ArrayList<StreamingRecognizeResponse> responses = new ArrayList<>();

            public void onStart(StreamController controller) {
                referenceToStreamController = controller;
            }

            public void onResponse(StreamingRecognizeResponse response) {
                responses.add(response);
                StreamingRecognitionResult result = response.getResultsList().get(0);
                Duration resultEndTime = result.getResultEndTime();
                resultEndTimeInMS = (int) ((resultEndTime.getSeconds() * 1000) + (resultEndTime.getNanos() / 1000000));
                double correctedTime = resultEndTimeInMS - bridgingOffset + (STREAMING_LIMIT * restartCounter);

                SpeechRecognitionAlternative alternative = result.getAlternativesList().get(0);
                String transcript = alternative.getTranscript();
                if (result.getIsFinal()) {
                    System.out.printf("%s: %s [confidence: %.2f]\n", convertMillisToDate(correctedTime), transcript, alternative.getConfidence());
                    isFinalEndTime = resultEndTimeInMS;
                    lastTranscriptWasFinal = true;
                } else {
                    System.out.printf("%s: %s", convertMillisToDate(correctedTime), transcript);
                    lastTranscriptWasFinal = false;
                }

                if (listener != null && !transcript.isEmpty()) {
                    listener.onTranscriptReceived(transcript);
                }
            }

            public void onComplete() {}

            public void onError(Throwable t) {}
        };

        ClientStream<StreamingRecognizeRequest> clientStream = speechClient.streamingRecognizeCallable().splitCall(responseObserver);

        RecognitionConfig recognitionConfig = RecognitionConfig.newBuilder()
                .setEncoding(RecognitionConfig.AudioEncoding.LINEAR16)
                .setLanguageCode(languageCode)
                .setSampleRateHertz(16000)
                .build();

        StreamingRecognitionConfig streamingRecognitionConfig = StreamingRecognitionConfig.newBuilder()
                .setConfig(recognitionConfig)
                .setInterimResults(true)
                .build();

        StreamingRecognizeRequest request = StreamingRecognizeRequest.newBuilder()
                .setStreamingConfig(streamingRecognitionConfig)
                .build();

        clientStream.send(request);

        long startTime = System.currentTimeMillis();

        while (true) {
            long estimatedTime = System.currentTimeMillis() - startTime;

            if (estimatedTime >= STREAMING_LIMIT) {
                clientStream.closeSend();
                referenceToStreamController.cancel();

                if (resultEndTimeInMS > 0) {
                    finalRequestEndTime = isFinalEndTime;
                }
                resultEndTimeInMS = 0;

                lastAudioInput = null;
                lastAudioInput = audioInput;
                audioInput = new ArrayList<>();

                restartCounter++;

                if (!lastTranscriptWasFinal) {
                    System.out.print('\n');
                }

                newStream = true;

                clientStream = speechClient.streamingRecognizeCallable().splitCall(responseObserver);

                request = StreamingRecognizeRequest.newBuilder()
                        .setStreamingConfig(streamingRecognitionConfig)
                        .build();

                startTime = System.currentTimeMillis();

            } else {
                if (newStream && lastAudioInput.size() > 0) {
                    double chunkTime = STREAMING_LIMIT / lastAudioInput.size();
                    if (chunkTime != 0) {
                        if (bridgingOffset < 0) {
                            bridgingOffset = 0;
                        }
                        if (bridgingOffset > finalRequestEndTime) {
                            bridgingOffset = finalRequestEndTime;
                        }
                        int chunksFromMs = (int) Math.floor((finalRequestEndTime - bridgingOffset) / chunkTime);
                        bridgingOffset = (int) Math.floor((lastAudioInput.size() - chunksFromMs) * chunkTime);
                        for (int i = chunksFromMs; i < lastAudioInput.size(); i++) {
                            request = StreamingRecognizeRequest.newBuilder()
                                    .setAudioContent(lastAudioInput.get(i))
                                    .build();
                            clientStream.send(request);
                        }
                    }
                    newStream = false;
                }

                try {
                    tempByteString = ByteString.copyFrom(sharedQueue.take());
                } catch (InterruptedException e) {
                    break;
                }

                request = StreamingRecognizeRequest.newBuilder()
                        .setAudioContent(tempByteString)
                        .build();

                audioInput.add(tempByteString);
                clientStream.send(request);
            }
        }
    }

    private class MicBuffer implements Runnable {
        @Override
        public void run() {
            targetDataLine.start();
            byte[] data = new byte[BYTES_PER_BUFFER];
            while (targetDataLine.isOpen()) {
                try {
                    int numBytesRead = targetDataLine.read(data, 0, data.length);
                    if (numBytesRead <= 0 && targetDataLine.isOpen()) {
                        continue;
                    }
                    sharedQueue.put(data.clone());
                } catch (InterruptedException e) {
                    break;
                }
            }
        }
    }

    private String convertMillisToDate(double milliSeconds) {
        long millis = (long) milliSeconds;
        DecimalFormat format = new DecimalFormat();
        format.setMinimumIntegerDigits(2);
        return String.format("%s:%s /", format.format(TimeUnit.MILLISECONDS.toMinutes(millis)), format.format(TimeUnit.MILLISECONDS.toSeconds(millis) - TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(millis))));
    }
}